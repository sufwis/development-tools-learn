工作区 -> 暂存区 ->仓库

git初始化指令：
git init //初始化仓库
git add 文件名 //把文件从工作区添加到暂存区
git commit -m “提交信息” //提交到仓库
git log //查看历史提交
git status
git reflog
git log --all --graph --decorate --oneline

git修改指令：
git checkout //切换分支或恢复工作区文件（但已不推荐用于撤销修改）

git reset HEAD <file_path>//把暂存区的文件移除到工作区；使用.移除全部
//该命令将文件从暂存区撤出（unstage），放回工作区（保留修改）
git restore --staged <file> //类似git reset HEAD <file_path>
git restore <file> //丢弃工作区更改

git reset --soft <commit_hash>/回退之后，之前提交的修改会重新变为暂存状态
//将 HEAD 移动到指定提交，但保留暂存区和工作区内容
//之前提交的更改会变为暂存状态（即已 add 但未 commit）

git reset --hard <commit_hash>//回退到哈希值的提交出，此后的一切修改会删除
//强制回退到指定提交，丢弃之后的所有提交、暂存区和工作区修改（谨慎使用，数据可能丢失
git revert <commit_hash>//创建一个新的提交来撤销指定提交所做的更改
//git revert 应用一个hash指后，就是指该提交的提交失效，如同前一个提交一样
但是历史提交没有改变

对于git reset --soft <commit_hash> 的问答：
之后的提交会怎样？
您重置目标提交之后的所有提交（即比 <commit_hash> 更新的提交）都会从当前分支的历史中消失。但是，这些提交所做的代码变更并不会丢失，而是变成了“已暂存”的状态（就像您用 git add 添加了一样），等待您再次提交。

再次提交会作为最后一次提交还是覆盖？
当您执行 git reset --soft 后立即执行 git commit，这次提交将会覆盖掉原来的历史。
新提交的哈希值会改变，它会成为分支新的最新提交（HEAD），而之前被重置掉的提交则会从分支历史中“消失”（在默认的 git log 中看不到，但可以通过 git reflog 临时找回）。

提交记录会？
分支的提交历史（history）被改写了。公共分支（如 main/master）通常不建议这样做，因为它会与其他协作者的历史产生冲突。它非常适合用于整理本地的、尚未推送（push）的提交。

之前提交的更改会变为暂存状态，但是与已经暂存的文件同名但不同，会？
答：Git 的暂存区（Staging Area）只能有一个文件版本。
如果您重置后带来的变更与暂存区中已存在的文件（同名）有冲突，那么新重置出来的变更会覆盖掉暂存区中原来的版本。
最终，暂存区中的文件内容将是重置操作所恢复出来的那个版本。


git 分支指令：
一般主分支是完成态，分支用于并行开发功能，分支之间分隔；分支完成后，合并到主分支，如果冲突，需要处理/先放弃合并，
git checkout -b <branch_name>//以当前分支为基础创建分支
git switch <branch_name> // 切换分支
git branch //查看全部分支
git branch -D <branchname>//删除分支
git branch <branchname> //创建分支
git merge <branchname>//合并分支
git stash  //  临时保存当前工作区和暂存区的修改
git stash pop // 恢复最近一次使用 git stash 保存的修改

在本地和远程仓库中
git pull//拉取
git push//推送

将本地分支推送到远程仓库
git push -u origin 你的分支名 //指定远程仓库名（通常是 origin）和分支名
git push -u <远程仓库名> <本地分支名>:<远程分支名> // 推送分支到远端分支

使用git reflog 复原误删操作
1.查看
# 查看 HEAD 的移动历史（最常用）
git reflog
# 查看特定分支的移动历史，例如 main
git reflog show main

2.输出解读
运行 git reflog 后，你会看到类似这样的输出：
c10a9a7 (HEAD -> main, origin/main) HEAD@{0}: reset: moving to HEAD~
5f8b3ef HEAD@{1}: commit: Add new feature X
c10a9a7 (HEAD -> main, origin/main) HEAD@{2}: commit: Fix the login bug
a23bd91 HEAD@{3}: pull origin main: Fast-forward
d4e6f89 HEAD@{4}: clone: from https://github.com/user/repo.git
提交哈希 (SHA-1)；
引用位置：HEAD@{0}, HEAD@{1}。{n} 中的数字代表这是第几步之前的状态。HEAD@{0} 是当前状态，HEAD@{1} 是上一步状态，依此类推

3.复原快照/分支
# 方式一：使用引用位置（更直观）
git reset --soft HEAD@{2}
# 方式二：使用提交哈希（效果相同）
git reset --soft 5f8b3ef

分支：
# 1. 在 reflog 里找到被删分支最后的提交，比如 a1b2c3d
git reflog
# 2. 基于该提交创建新分支
git branch feature-new a1b2c3d

本地且有时效性：Reflog 只存在于你的本地仓库。你无法看到同事的 reflog，他们也无法看到你的。它不会被 push 到远程。
会过期：Git 会定期清理过时的 reflog 记录（默认 90 天）
不是项目历史：它记录的是引用移动的日志，而不是项目的提交历史。不要用它来替代 git log。
安全网：它的存在意味着你在本地几乎很难真正“丢失”提交，这让你可以更自信地尝试各种危险的 Git 命令。


git别名：
1.使用 git config 命令（适用于快速添加）
git config --global alias.<缩写> <原命令>
<原命令>不带git，使用""
设置局部别名（仅对当前仓库有效）：
只需去掉 --global 参数即可9。
2.直接编辑配置文件（适用于批量添加或修改）
.gitconfig
例如：
.gitconfig

//强制修改当前分支名
git branch -M

某些IDE有更便捷的插件
其中vscode和VS略有不同


基础指令：
基础
git help <command>: 获取 git 命令的帮助信息
git init: 创建一个新的 git 仓库，其数据会存放在一个名为 .git 的目录下
git status: 显示当前的仓库状态
git add <filename>: 添加文件到暂存区
git commit: 创建一个新的提交
如何编写 良好的提交信息!
为何要 编写良好的提交信息
git log: 显示历史日志
git log --all --graph --decorate: 可视化历史记录（有向无环图）
git diff <filename>: 显示与暂存区文件的差异
git diff <revision> <filename>: 显示某个文件两个版本之间的差异
git checkout <revision>: 更新 HEAD（如果是检出分支则同时更新当前分支）

分支和合并
git branch: 显示分支
git branch <name>: 创建分支
git checkout -b <name>: 创建分支并切换到该分支
相当于 git branch <name>; git checkout <name>
git merge <revision>: 合并到当前分支
git mergetool: 使用工具来处理合并冲突
git rebase: 将一系列补丁变基（rebase）为新的基线


远端操作
git remote: 列出远端
git remote add <name> <url>: 添加一个远端
git push <remote> <local branch>:<remote branch>: 将对象传送至远端并更新远端引用
git branch --set-upstream-to=<remote>/<remote branch>: 创建本地和远端分支的关联关系
git fetch: 从远端获取对象/索引
git pull: 相当于 git fetch; git merge
git clone: 从远端下载仓库


撤销
git commit --amend: 编辑提交的内容或信息
git reset HEAD <file>: 恢复暂存的文件
git checkout -- <file>: 丢弃修改
git restore: git2.32 版本后取代 git reset 进行许多撤销操作


Git 高级操作
git config: Git 是一个 高度可定制的 工具
git clone --depth=1: 浅克隆（shallow clone），不包括完整的版本历史信息
git add -p: 交互式暂存
git rebase -i: 交互式变基
git blame: 查看最后修改某行的人
git stash: 暂时移除工作目录下的修改内容
git bisect: 通过二分查找搜索历史记录
.gitignore: 指定 故意不追踪的文件



简单原理介绍见：
https://missing-semester-cn.github.io/2020/version-control/
-1.-Git 的数据模型
进行版本控制的方法很多。Git 拥有一个经过精心设计的模型，这使其能够支持版本控制所需的所有特性，例如维护历史记录、支持分支和促进协作。
