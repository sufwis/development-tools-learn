-1.-任务控制
Ctrl-C 来停止命令的执行。
但是它的工作原理是什么呢？为什么有的时候会无法结束进程？
1.1结束进程
您的 shell 会使用 UNIX 提供的信号机制执行进程间通信。当一个进程接收到信号时，它会停止执行、处理该信号并基于信号传递的信息来改变其执行。就这一点而言，信号是一种 软件中断。

在上面的例子中，当我们输入 Ctrl-C 时，shell 会发送一个 SIGINT 信号到进程。
然而程序可以捕获信号 SIGINT 并忽略它的基本操作
我们需要使用 SIGQUIT 信号，通过输入 Ctrl-\ 可以发送该信号

尽管 SIGINT 和 SIGQUIT 都常常用来发出和终止程序相关的请求。SIGTERM 则是一个更加通用的、也更加优雅地退出信号。为了发出这个信号我们需要使用 kill 命令, 它的语法是： kill -TERM <PID>。

kill -TERM PID与 kill %num 区别
kill -TERM <PID> 针对进程 ID（PID），kill %num 针对作业控制中的作业号（Job Number）
kill -TERM <PID>：明确指定发送 TERM 信号（即 SIGTERM，信号编号 15），这是一种 “友好终止” 信号 —— 进程会收到通知，有机会清理资源（如保存文件、关闭连接）后退出。
kill %num：未指定信号时，默认发送的也是 SIGTERM 信号（与 kill -TERM 的信号类型一致）。
仅当满足以下 2 个条件时，两者效果才可能一致：
%num 对应的作业仅包含一个进程（即作业的 PID 等于 <PID>）；
未手动修改 kill 命令的默认信号（默认就是 SIGTERM）。
   
kill -STOP %1 暂停作业1
kill -CONT %1 作业1继续在后台执行

核心转储是指接受SIGQUIT信号/程序意外终止，将其快照存为一个文件，通常命名为core.PID，可用以调试。或调用apport自动处理崩溃报告。

1.2 暂停和后台执行进程
SIGSTOP 会让进程暂停
在终端中，Ctrl-Z 会让 shell 发送 SIGTSTP 信号
SIGTSTP 是 Terminal Stop 的缩写（即 terminal 版本的 SIGSTOP）

我们可以使用 fg 或 bg 命令恢复暂停的工作。它们分别表示在前台继续或在后台继续。
jobs -l 命令会列出当前终端会话中尚未完成的全部任务
 pid 引用这些任务（也可以用 pgrep 找出 pid）
您可以使用百分号 + 任务编号（jobs 会打印任务编号）来选取该任务
最近的一个任务，可以使用 $! 这一特殊参数

命令中的 & 后缀可以让命令在直接在后台运行
不过它此时还是会使用 shell 的标准输出，这一点有时会比较恼人（这种情况可以使用 shell 重定向处理）。

让已经在运行的进程转到后台运行，您可以键入 Ctrl-Z ，然后紧接着再输入 bg。注意，后台的进程仍然是您的终端进程的子进程，一旦您关闭终端（会发送另外一个信号 SIGHUP），这些后台的进程也会终止。为了防止这种情况发生，您可以使用 nohup（一个用来忽略 SIGHUP 的封装）来运行程序

针对已经运行的程序，可以使用 disown 。除此之外，您可以使用终端多路复用器来实现，
disown 是一个内置命令，用于从当前 shell 的作业列表中移除指定的后台作业，这样当 shell 退出时，这些作业不会被终止
disown %<作业号>
移除指定作业号的后台进程（作业号可通过 jobs 命令查看）：


jobs -l信息：
[作业号] 状态  进程号  命令
Running：作业正在后台运行。
Stopped：作业被暂停（通常是收到 SIGTSTP 信号，如按 Ctrl+Z 暂停）。
Done：作业已完成并退出（退出状态码为 0 时显示，若非 0 则显示 Done(code)）。
Terminated：作业被终止（如通过 kill 命令结束）。


1.3 终端多路复用
像 tmux 这类的终端多路复用器可以允许我们基于面板和标签分割出多个终端窗口，这样您便可以同时与多个 shell 会话进行交互。

tmux 的快捷键需要我们掌握，它们都是类似 <C-b> x 这样的组合，即需要先按下 Ctrl+b，松开后再按下 x。tmux 中对象的继承结构如下：

会话 - 每个会话都是一个独立的工作区，其中包含一个或多个窗口
tmux 开始一个新的会话
tmux new -s NAME 以指定名称开始一个新的会话
tmux ls 列出当前所有会话
在 tmux 中输入 <C-b> d ，将当前会话分离
tmux a 重新连接最后一个会话。您也可以通过 -t 来指定具体的会话
tmux kill-session -t  0 删除会话


窗口 - 相当于编辑器或是浏览器中的标签页，从视觉上将一个会话分割为多个部分
个会话可以包含多个窗口。每个窗口就相当于一个独立的终端界面，拥有自己的命令历史记录和工作目录
<C-b> c 创建一个新的窗口，使用 <C-d> 关闭
<C-b> N 跳转到第 N 个窗口，注意每个窗口都是有编号的
<C-b> p 切换到前一个窗口
<C-b> n 切换到下一个窗口
<C-b> , 重命名当前窗口
<C-b> w 列出当前所有窗口

面板 - 像 vim 中的分屏一样，面板使我们可以在一个屏幕里显示多个 shell
面板是 tmux 中最小的工作区域，每个面板都可以独立运行一个进程，一个伪终端
<C-b> " 水平分割
<C-b> % 垂直分割
<C-b> <方向> 切换到指定方向的面板，<方向> 指的是键盘上的方向键
<C-b> z 切换当前面板的缩放
<C-b> [ 开始往回卷动屏幕。您可以按下空格键来开始选择，回车键复制选中的部分
当按下 <C-b> [ 后，tmux 会进入复制模式（类似终端的滚动查看模式），此时可以通过方向键（或 vim 风格的 j/k）向上 / 向下滚动屏幕内容，查看历史输出。
在复制模式中：
按空格键开始选中文本（进入选择模式）
移动光标选择需要复制的内容
按回车键确认复制，此时选中的内容会被保存到 tmux 的缓冲区中
之后可以在 tmux 的其他面板 / 窗口中，通过 <C-b> ] 将复制的内容粘贴出来。
<C-b> <空格> 在不同的面板排布间切换

1.4 别名
alias alias_name="command_to_alias arg1 arg2"
注意， = 两边是没有空格的，因为 alias 是一个 shell 命令，它只接受一个参数。

值得注意的是，在默认情况下 shell 并不会保存别名。为了让别名持续生效，您需要将配置放进 shell 的启动文件里，像是 .bashrc 或 .zshrc，下一节我们就会讲到。

1.5 配置文件（Dotfiles）
对于 bash 来说，在大多数系统下，您可以通过编辑 .bashrc 或 .bash_profile 来进行配置。在文件中您可以添加需要在启动时执行的命令，例如上文我们讲到过的别名，或者是您的环境变量

实际上，很多程序都要求您在 shell 的配置文件中包含一行类似 export PATH="$PATH:/path/to/program/bin" 的命令，这样才能确保这些程序能够被 shell 找到。

还有一些其他的工具也可以通过 点文件 进行配置：

bash - ~/.bashrc, ~/.bash_profile
git - ~/.gitconfig
vim - ~/.vimrc 和 ~/.vim 目录
ssh - ~/.ssh/config
tmux - ~/.tmux.conf

我们应该如何管理这些配置文件呢，它们应该在它们的文件夹下，并使用版本控制系统进行管理，然后通过脚本将其 符号链接(软连接) 到需要的地方
具体如何做？
集中管理：所有配置文件（如 .bashrc、.vimrc、.gitconfig 等）可以统一存放在一个文件夹（如 ~/dotfiles）中，方便用 Git 跟踪修改、备份和同步到多台设备。
不破坏系统默认路径：系统会默认在 ~/.bashrc、~/.vimrc 等位置查找配置文件，通过符号链接可以让系统 “以为” 配置文件还在原地，实际却指向版本控制文件夹中的文件。
灵活更新：修改版本控制文件夹中的配置文件后，无需手动复制到系统路径，符号链接会自动指向更新后的内容。

可移植性


-2.- 远端设备
安全 shell（SSH）

通过如下命令，您可以使用 ssh 连接到其他服务器：
ssh foo@bar.mit.edu
这里我们尝试以用户名 foo 登录服务器 bar.mit.edu。服务器可以通过 URL 指定（例如 bar.mit.edu），也可以使用 IP 指定（例如 foobar@192.168.1.42）

ssh 命令中的 -p 参数用于指定连接远程服务器时使用的 端口号（默认情况下，SSH 协议使用 22 端口）。
当远程服务器的 SSH 服务没有使用默认的 22 端口（例如为了安全考虑修改了端口），就需要用 -p 参数指定实际端口。

执行命令
ssh 的一个经常被忽视的特性是它可以直接远程执行命令
ssh foobar@server ls | grep PATTERN 会在本地查询远端 ls 的输出而 ls | ssh foobar@server grep PATTERN 会在远端对本地 ls 输出的结果进行查询。
本地执行：未通过 ssh 连接时，或在 ssh 命令前加上本地操作（如 ssh user@host "command" 中的 command 是远程执行，但本地终端直接输入的命令是本地）。
远程执行：一旦进入 ssh 交互会话（即成功登录到远程），后续输入的所有命令默认都在远程服务器运行。


SSH 密钥
基于密钥的验证机制使用了密码学中的公钥，我们只需要向服务器证明客户端持有对应的私钥，而不需要公开其私钥。这样您就可以避免每次登录都输入密码的麻烦了

密钥生成
ssh-keygen
  指定密钥保存路径：默认保存在 ~/.ssh/id_rsa（Linux/macOS）或 C:\Users\用户名\.ssh\id_rsa（Windows），直接按回车使用默认路径。
  设置密钥密码（可选）：输入密码（后续使用密钥时需验证），或直接按两次回车跳过（无密码）
  生成成功后，会在指定路径创建两个文件：
id_rsa：私钥（必须妥善保管，不可泄露）
id_rsa.pub：公钥（可公开，用于配置到远程服务器）

基于密钥的认证机制
使用私钥登录需先将对应的公钥上传到远程服务器，再通过私钥验证身份。
  用 ssh-copy-id 命令自动复制公钥到远程服务器的 ~/.ssh/authorized_keys 文件（推荐）：
  # 格式：ssh-copy-id -i 公钥路径 远程用户名@远程IP
  ssh-copy-id -i ~/.ssh/id_rsa.pub ubuntu@192.168.1.105
若没有 ssh-copy-id（如 Windows），可手动复制公钥内容：
服务器的 ~/.ssh/authorized_keys 文件：存储所有允许登录该服务器的 “客户端公钥”，相当于 “白名单”，仅公钥对应的私钥能通过验证。

  上传公钥后，即可用私钥登录（无需输入远程服务器密码）：
# 格式：ssh -i 私钥路径 远程用户名@远程IP
ssh -i ~/.ssh/id_rsa ubuntu@192.168.1.105
若私钥是默认路径（~/.ssh/id_rsa），可省略 -i 参数，SSH 会自动查找：
ssh ubuntu@192.168.1.105


通过 SSH 复制文件
使用 ssh 复制文件有很多方法：
ssh+tee, 最简单的方法是执行 ssh 命令，然后通过这样的方法利用标准输入实现 cat localfile | ssh remote_server tee serverfile。回忆一下，tee 命令会将标准输出写入到一个文件；
scp ：当需要拷贝大量的文件或目录时，使用 scp 命令则更加方便，因为它可以方便的遍历相关路径。语法如下：scp path/to/local_file remote_host:path/to/remote_file；
rsync 对 scp 进行了改进，它可以检测本地和远端的文件以防止重复拷贝。它还可以提供一些诸如符号连接、权限管理等精心打磨的功能。甚至还可以基于 --partial 标记实现断点续传。rsync 的语法和 scp 类似；

scp [本地文件路径] [远程用户]@[远程IP或域名]:[远程目标路径]
scp [远程用户]@[远程IP或域名]:[远程文件路径] [本地目标路径]

SCP命令的执行位置决定了它能访问的文件系统，SCP命令总是在包含源文件的那一端执行

-P 指定端口


端口转发
很多情况下我们都会遇到软件需要监听特定设备的端口。如果是在您的本机，可以使用 localhost:PORT 或 127.0.0.1:PORT。但是如果需要监听远程服务器的端口该如何操作呢？这种情况下远端的端口并不会直接通过网络暴露给您。
此时就需要进行 端口转发。端口转发有两种，本地端口转发和远程端口转发
>
常见的情景是使用本地端口转发，即远端设备上的服务监听一个端口，而您希望在本地设备上的一个端口建立连接并转发到远程端口上。例如，我们在远端服务器上运行 Jupyter notebook 并监听 8888 端口。 然后，建立从本地端口 9999 的转发，使用 ssh -L 9999:localhost:8888 foobar@remote_server 。这样只需要访问本地的 localhost:9999 即可。
ssh -L [本地端口]:[目标主机]:[目标端口] [远程服务器用户名]@[远程服务器地址]
>
ssh -R [远程服务器端口]:[本地目标主机]:[本地目标端口] [远程服务器用户名]@[远程服务器地址]
本地

# 第一步：建立SSH隧道
ssh -L 10022:localhost:22 user@example.com -p 2222
# 这里 -p 2222 表示：通过2222端口连接到 example.com

# 第二步：使用SCP通过转发的端口
scp -P 10022 local_file.txt user@localhost:/remote/path/
# 这里 -P 10022 表示：通过10022端口连接到本地的SCP服务

你的SCP客户端 → localhost:10022 → SSH隧道 → example.com:2222 → 远程服务器的22端口
ssh -p：指定SSH连接的目标端口
scp -P：指定SCP连接的目标端口
端口转发后，SCP连接的是本地的转发端口，但数据最终会到达远程的目标端口


SSH 配置
我们已经介绍了很多参数。为它们创建一个别名是个好想法，我们可以这样做：
不过，更好的方法是使用 ~/.ssh/config.
这么做的好处是，使用 ~/.ssh/config 文件来创建别名，类似 scp、rsync 和 mosh 的这些命令都可以读取这个配置并将设置转换为对应的命令行选项。
服务器侧的配置通常放在 /etc/ssh/sshd_config


杂项
连接远程服务器的一个常见痛点是遇到由关机、休眠或网络环境变化导致的掉线。如果连接的延迟很高也很让人讨厌。Mosh（即 mobile shell ）对 ssh 进行了改进，它允许连接漫游、间歇连接及智能本地回显。
有时将一个远端文件夹挂载到本地会比较方便， sshfs 可以将远端服务器上的一个文件夹挂载到本地，然后您就可以使用本地的编辑器了。

-3.- Shell & 框架
在 shell 工具和脚本那节课中我们已经介绍了 bash shell，因为它是目前最通用的 shell，大多数的系统都将其作为默认 shell。但是，它并不是唯一的选项。
框架 也可以改进您的 shell。比较流行的通用框架包括 prezto 或 oh-my-zsh。还有一些更精简的框架，它们往往专注于某一个特定功能

需要注意的是，使用这些框架可能会降低您 shell 的性能，尤其是如果这些框架的代码没有优化或者代码过多。您随时可以测试其性能或禁用某些不常用的功能来实现速度与功能的平衡。


-4.- 终端模拟器
和自定义 shell 一样，花点时间选择适合您的 终端模拟器 并进行设置是很有必要的。有许多终端模拟器可供您选择（这里有一些关于它们之间 比较 的信息）

您会花上很多时间在使用终端上，因此研究一下终端的设置是很有必要的，您可以从下面这些方面来配置您的终端：

字体选择
彩色主题
快捷键
标签页/面板支持
回退配置
性能（像 Alacritty 或者 kitty 这种比较新的终端，它们支持 GPU 加速）

终端是 “你与计算机命令行交互的‘窗口 / 设备’”（载体）；
命令行是 “你通过输入文本命令控制计算机的‘方式’”（交互逻辑）。
日常使用中 “打开终端就是用命令行”，是因为终端默认关联了 shell—— 但二者的本质角色完全不同。
