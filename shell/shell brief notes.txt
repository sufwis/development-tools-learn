-1-.shell 概述
1.1.shell是？
计算机的一种文字接口。

1.2使用 shell
执行+命令行传参
在PATH中记载可执行程序的目录，使用命令时
从中查找
-通过echo $PATH可以查看PATH

1.3在 shell 中导航
详见Linux目录基础操作

1.4在程序间创建连接
即重定向
最简单的重定向是 < file 和 > file
>>写入
>覆盖
| 操作符允许我们将一个程序的输出和另外一个程序的输入连接起来

1.5一个功能全面又强大的工具
根用户才能做的，那就是向 sysfs 文件写入内容。系统被挂载在 /sys 下，sysfs 文件则暴露了一些内核（kernel）参数

例如：
$ sudo echo 3 > brightness//(这是一个控制屏幕亮度的文件)
输出：
An error occurred while redirecting file 'brightness'
open: Permission denied
这是因为：
|、>、和 < 是通过 shell 执行的，而不是被各个程序单独执行
sudo echo 3 具有权限
但是shell在打开brightness准备>时
不具有权限
:echo 3 | sudo tee brightness
tee 是一个常用的命令行工具，其主要功能是从标准输入读取数据，同时将数据输出到标准输出（屏幕）和一个或多个文件中。
此时打开 /sys 文件的是 tee 这个程序，并且该程序以 root 权限在运行


-2.-shell工具和脚本
1.bash 脚本
很多情况下我们需要执行一系列的操作并使用条件或循环这样的控制流
1.1变量赋值
1.1.1普通变量
foo=bar，访问变量中存储的数值，其语法为 $foo。 需要注意的是，foo = bar （使用空格隔开）是不能正确工作的
shell 脚本中使用空格会起到分割参数的作用，有时候可能会造成混淆

1.1.2变量的使用
$varname取值
$(cmd) 执行cmd并将结果替换

对于使用变量也可以加上{}即:
${var}
{}用于区分边界
如    echo "I am good at ${skill}Script"
如果不加{}，skillScript会被作为变量处理
推荐使用{}

同时，变量可以被重新定义

@：
在数组上下文中，@ 表示数组中的所有元素。
对于普通索引数组（如 arr=(a b c)），"${arr[@]}" 会返回所有元素 a b c。
对于关联数组，"${user_details[@]}" 会返回所有值（value）（如 "Bob" "工程师" "TechCorp"）。
!：
这是关联数组特有的语法，加在数组名前表示取所有键（key），而非值。
因此 ${!user_details[@]} 会返回关联数组的所有键（如 "姓名" "职业" "公司"）。

1.1.3只读变量
使用readonly
var=value
readonly var

1.1.4删除变量
unset varname
但是不能删除只读

1.1.5变量类型
Shell 支持不同类型的变量，其中一些主要的类型包括：
字符串变量： 在 Shell中，变量通常被视为字符串。
你可以使用单引号 ' 或双引号 " 来定义字符串，例如：

整数变量： 在一些Shell中，你可以使用 declare 或 typeset 命令来声明整数变量。

数组变量： Shell 也支持数组，允许你在一个变量中存储多个值。
数组可以是整数索引数组或关联数组
整数索引数组
my_array=(1 2 3 4)
关联数组：
declare -A associative_array
associative_array["name"]="John"

环境变量： 这些是由操作系统或用户设置的特殊变量，用于配置 Shell 的行为和影响其执行环境。
例如，PATH 变量包含了操作系统搜索可执行文件的路径：

特殊变量： 有一些特殊变量在 Shell 中具有特殊含义，例如 $0 表示脚本的名称，$1, $2, 等表示脚本的参数。



2.字符串
Bash 中的字符串通过 ' 和 " 分隔符来定义，但是它们的含义并不相同。以 ' 定义的字符串为原义字符串，其中的变量不会被转义，而 " 定义的字符串会将变量值进行替换。

如何执行？
作为可执行程序 ./test.sh
注意带上./，否则命令解释器会从PATH中寻找它
或者调用解释器
/usr/bin/bash test.sh

3.和其他大多数的编程语言一样，bash 也支持 if, case, while 和 for 这些控制流关键字。同样地， bash 也支持函数

if流程控制，其中[]建议采用[[]]:
if [ 条件 ]; then
    命令1
elif [ 条件 ]; then
    命令2
else
    命令3
fi

case流程控制：
case $变量 in
    模式1)
        命令1
        ;;
    模式2)
        命令2
        ;;
    *)
        默认命令
        ;;
esac
模式可以是固定字符串、通配符：
* ？ [其内任意个字符]  | 分隔的多个模式


for流程控制：
1.列表风格
for 变量 in 列表; do
    命令
done
2.c语言风格
for ((i=起始值; i<=结束值; i++)); do
    命令
done

while流程控制：
while [ 条件 ]; do
    命令
done

函数：
函数名() {
    命令
    [return 返回值]
}

函数示例：
mcd () {
    mkdir -p "$1"
    cd "$1"
}
函数调用无() 参数直接放后面即可
定义也不用写形参

这里 $1 是脚本的第一个参数。与其他脚本语言不同的是，bash 使用了很多特殊的变量来表示参数、错误代码和相关变量

$0 - 脚本名
$1 到 $9 - 脚本的参数。 $1 是第一个参数，依此类推。
$@ - 所有参数
$# - 参数个数
$? - 前一个命令的返回值
$$ - 当前脚本的进程识别码
!! - 完整的上一条命令，包括参数。常见应用：当你因为权限不足执行命令失败时，可以使用 sudo !! 再尝试一次。
$_ - 上一条命令的最后一个参数。如果你正在使用的是交互式 shell，你可以通过按下 Esc 之后键入 . 来获取这个值。
$HOME家目录

条件的比较的操作符：
数字：
-eq	等于	if [ 5 -eq 3 ]; then ...
-ne	不等于	if [ 5 -ne 3 ]; then ...
-gt	大于（greater than）	if [ 5 -gt 3 ]; then ...
-lt	小于（less than）	if [ 5 -lt 3 ]; then ...
-ge	大于等于	if [ 5 -ge 3 ]; then ...
-le	小于等于	if [ 5 -le 3 ]; then ...
字符串：
=	等于（注意空格）	if [ "$str1" = "$str2" ]; then ...
!=	不等于	if [ "$str1" != "$str2" ]; then ...
-z	字符串长度为 0	if [ -z "$str" ]; then ...
-n	字符串长度不为 0	if [ -n "$str" ]; then ...
文件：
-e	文件 / 目录存在	if [ -e "file.txt" ]; then ...
-f	是普通文件	if [ -f "file.txt" ]; then ...
-d	是目录	if [ -d "dir" ]; then ...
-r	文件可读	if [ -r "file.txt" ]; then ...
-w	文件可写	if [ -w "file.txt" ]; then ...
-x	文件可执行	if [ -x "script.sh" ]; then ...
逻辑判断：
与：[ 条件1 ] && [ 条件2 ] 或 [[ 条件1 && 条件2 ]]
或：[ 条件1 ] || [ 条件2 ] 或 [[ 条件1 || 条件2 ]]
非：[ ! 条件 ] 或 [[ ! 条件 ]]

[[]]需要在[]两侧留出空格
$(())内做算术运算

4.退出码
命令通常使用 STDOUT 来返回输出值，使用 STDERR 来返回错误及错误码
返回值 0 表示正常执行
程序 true 的返回码永远是 0，false 的返回码永远是 1。

退出码可以搭配 &&（与操作符）和 ||（或操作符）使用，用来进行条件判断，决定是否执行其他程序
它们都属于 短路运算符（short-circuiting）

同一行的多个命令可以用 ; 分隔

示例：
false || echo "Oops, fail"
# Oops, fail

true || echo "Will not be printed"
#

true && echo "Things went well"
# Things went well

false && echo "Will not be printed"
#

false ; echo "This will always run"
# This will always run

5.命令替换 进程替换
$( CMD ) 这样的方式来执行 CMD 这个命令时，它的输出结果会替换掉 $( CMD ) 。例如，如果执行 for file in $(ls) ，shell 首先将调用 ls ，然后遍历得到的这些返回值

 <( CMD ) 会执行 CMD 并将结果输出到一个临时文件中，并将 <( CMD ) 替换成临时文件名。这在我们希望返回值通过文件而不是 STDIN 传递时很有用。例如， diff <(ls foo) <(ls bar) 会显示文件夹 foo 和 bar 中文件的区别。
diff 是一个用于比较两个文件内容差异的命令行工具

6.shebang
在 shebang 行中使用 env 命令是一种好的实践，它会利用环境变量中的程序来解析该脚本，这样就提高了您的脚本的可移植性
env 会利用我们第一节讲座中介绍过的 PATH 环境变量来进行定位

例如写python脚本：
#!/usr/local/bin/python
#!/usr/bin/env python

shebang（也称为 hashbang）是脚本文件的第一行，用于指定执行该脚本的解释器程序。
#!/路径/到/解释器
#! 是 shebang 的标志（必须放在文件的第一行，且前面不能有任何字符，包括空格）
后面跟随的是解释器的绝对路径（如 /bin/bash、/usr/bin/python3 等）
使用该解释器来执行脚本内容，而无需手动指定解释器（如 bash script.sh）。

虽然并不严格依赖后缀执行脚本：
.sh：最常用的通用后缀，可用于 Bash 及其他 shell 脚本
.bash：更明确地表示这是 Bash 专属脚本（包含 Bash 特有语法）

7.通配符和{}
通配符 - 当你想要利用通配符进行匹配时，你可以分别使用 ? 和 * 来匹配一个或任意个字符， [a-z]
花括号 {} - 当你有一系列的指令，其中包含一段公共子串时，可以用花括号来自动展开这些命令
例如：
convert image.{png,jpg}
# 会展开为
convert image.png image.jpg
mv *{.py,.sh} folder
# 会移动所有 *.py 和 *.sh 文件

编写 bash 脚本有时候会很别扭和反直觉。例如 shellcheck 这样的工具可以帮助你定位 sh/bash 脚本中的错误。

8.source与bash
source 是什么？
source 是一个 Bash 内建命令。它的作用是：在当前 Shell 会话中读取并执行指定脚本文件中的命令。
最关键的一点是： 它不是在启动一个子 Shell 来运行脚本，而是直接将脚本的内容“注入”到当前正在运行的 Shell 环境中来执行。

脚本文件本身没有被缓存为一个独立的实体。而是脚本中的命令（尤其是变量赋值、函数定义等）直接影响了当前 Shell 进程的内存状态。

“直接通过bash函数名调用它”：这是完全正确的，但这是结果，而非 source 本身的功能。source 负责将函数定义载入当前 Shell 的内存。一旦定义完成，你就可以像调用内置命令一样直接调用这个函数名。

9.重定向
脚本中
>&2 echo/other....
将后者输出重定向到标准错误
命令行中
cmd >2 
将标准错误（stderr）重定向到指定文件

总结.shell函数与脚本不同：
-函数只能与 shell 使用相同的语言，脚本可以使用任意语言。因此在脚本中包含 shebang 是很重要的。
-函数仅在定义时被加载，脚本会在每次被执行时加载。这让函数的加载比脚本略快一些，但每次修改函数定义，都要重新加载一次。
-函数会在当前的 shell 环境中执行，脚本会在单独的进程中执行。因此，函数可以对环境变量进行更改，比如改变当前工作目录，脚本则不行。使用 export 导出的环境变量会以传值的方式传递给脚本。
-与其他程序语言一样，函数可以提高代码模块性、代码复用性并创建清晰性的结构。shell 脚本中往往也会包含它们自己的函数定义。
-shell是一种脚本语言/命令行解释器，但脚本不只是shell


-3.-Shell工具初步
1.查看命令如何使用
为对应的命令行添加 -h 或 --help 标记。另外一个更详细的方法则是使用 man 命令
 有时手册太过详实。TLDR pages 是一个很不错的替代品，它提供了一些案例，可以帮助您快速找到正确的选项。

2.查找文件
find
fd
locate
which

3.查找代码
grep 正则
 -C ：获取查找结果的上下文（Context）；-v 将对结果进行反选（Invert），也就是输出不匹配的结果
此外还有：
ack 
ag
rg

-2-3 -> 重要的是你要知道有些问题使用合适的工具就会迎刃而解，而具体选择哪个工具则不是那么重要

4.查找 shell 命令
history 命令允许您以程序员的方式来访问 shell 中输入的历史命令
用管道将输出结果传递给 grep 进行模式搜索。 history | grep str

对于大多数的 shell 来说，您可以使用 Ctrl+R 对命令历史记录进行回溯搜索。敲 Ctrl+R 后您可以输入子串来进行匹配，查找历史命令行

zsh fzf fish

在 .bashrc 中添加 HISTCONTROL=ignorespace
在命令的开头加上一个空格，它就不会被加进 shell 记录中

5.文件夹导航
但是如何才能高效地在目录间随意切换呢？有很多简便的方法可以做到，比如设置 alias，使用 ln -s 创建符号连接等

我们可以使用 fasd 和 autojump 这两个工具来查找最常用或最近使用的文件和目录

还有一些更复杂的工具可以用来概览目录结构，例如 tree, broot 或更加完整的文件管理器，例如 nnn 或 ranger。


-4.-vim概述
详细见linux基础操作-vim
补充：
Vim 会维护一系列打开的文件，称为“缓存”。一个 Vim 会话包含一系列标签页，每个标签页包含 一系列窗口（分隔面板）。每个窗口显示一个缓存。跟网页浏览器等其他你熟悉的程序不一样的是， 缓存和窗口不是一一对应的关系；窗口只是缓冲区的视图。一个缓存可以在 多个 窗口打开，甚至在同一 个标签页内的多个窗口打开。这个功能其实很好用，比如可以查看同一个文件的不同部分。

1.Vim 的接口其实是一种编程语言
1.1移动
多数时候你会在正常模式下，使用移动命令在缓存中导航
在 Vim 里面移动也被称为 “名词”， 因为它们指向文字块
基本移动: hjkl （左， 下， 上， 右）
词： w （下一个词）， b （词初）， e （词尾）
行： 0 （行初）， ^ （第一个非空格字符）， $ （行尾）
屏幕： H （屏幕首行）， M （屏幕中间）， L （屏幕底部）
翻页： Ctrl-u （上翻）， Ctrl-d （下翻）
文件： gg （文件头）， G （文件尾）
行数： :{行数}<CR> 或者 {行数}G ({行数}为行数)
杂项： % （找到配对，比如括号或者 /* */ 之类的注释对）
查找： f{字符}， t{字符}， F{字符}， T{字符}
查找/到 向前/向后 在本行的{字符}
, / ; 用于导航匹配
搜索: /{正则表达式}, n / N 用于导航匹配

1.2选择
可视化模式:
可视化：v
可视化行： V
可视化块：Ctrl+v

1.3编辑
所有你需要用鼠标做的事， 你现在都可以用键盘：采用编辑命令和移动命令的组合来完成。 这就是 Vim 的界面开始看起来像一个程序语言的时候。Vim 的编辑命令也被称为 “动词”， 因为动词可以施动于名词。

1.4计数
你可以用一个计数来结合“名词”和“动词”，这会执行指定操作若干次。

1.5修饰语
你可以用修饰语改变“名词”的意义。修饰语有 i，表示“内部”或者“在内”，和 a， 表示“周围”。
ci( 改变当前括号内的内容
ci[ 改变当前方括号内的内容
da' 删除一个单引号字符串， 包括周围的单引号


2.自定义 Vim
Vim 由一个位于 ~/.vimrc 的文本配置文件（包含 Vim 脚本命令）。你可能会启用很多基本 设置。
Vim 能够被重度自定义，花时间探索自定义选项是值得的

3.扩展 Vim
你可以使用内置的插件管理系统。只需要创建一个 ~/.vim/pack/vendor/start/ 的文件夹，然后把插件放到这里（比如通过 git clone）
或者启用其他vim插件管理器，例如VimPlug

4.其他程序的 Vim 模式

5.Vim 进阶
搜索和替换
:s （替换）命令
多窗口
宏